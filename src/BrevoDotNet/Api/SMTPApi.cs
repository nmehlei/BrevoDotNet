// <auto-generated>
/*
 * SendinBlue API
 *
 * SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :- -- -- -- -- -- --: | - -- -- -- -- -- -- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@sendinblue.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using BrevoDotNet.Client;
using BrevoDotNet.Model;
using System.Diagnostics.CodeAnalysis;

namespace BrevoDotNet.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ISMTPApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        SMTPApiEvents Events { get; }

        /// <summary>
        /// Add a new domain to the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Blocks a new domain in order to avoid messages being sent to the same
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="blockDomain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBlockNewDomainApiResponse"/>&gt;</returns>
        Task<IBlockNewDomainApiResponse> BlockNewDomainAsync(BlockDomain blockDomain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add a new domain to the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Blocks a new domain in order to avoid messages being sent to the same
        /// </remarks>
        /// <param name="blockDomain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBlockNewDomainApiResponse"/>?&gt;</returns>
        Task<IBlockNewDomainApiResponse?> BlockNewDomainOrDefaultAsync(BlockDomain blockDomain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateSmtpTemplateApiResponse"/>&gt;</returns>
        Task<ICreateSmtpTemplateApiResponse> CreateSmtpTemplateAsync(CreateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateSmtpTemplateApiResponse"/>?&gt;</returns>
        Task<ICreateSmtpTemplateApiResponse?> CreateSmtpTemplateOrDefaultAsync(CreateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unblock an existing domain from the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Unblocks an existing domain from the list of blocked domains
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The name of the domain to be deleted</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBlockedDomainApiResponse"/>&gt;</returns>
        Task<IDeleteBlockedDomainApiResponse> DeleteBlockedDomainAsync(string domain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unblock an existing domain from the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Unblocks an existing domain from the list of blocked domains
        /// </remarks>
        /// <param name="domain">The name of the domain to be deleted</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBlockedDomainApiResponse"/>?&gt;</returns>
        Task<IDeleteBlockedDomainApiResponse?> DeleteBlockedDomainOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete hardbounces
        /// </summary>
        /// <remarks>
        /// Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteHardbounces">values to delete hardbounces (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteHardbouncesApiResponse"/>&gt;</returns>
        Task<IDeleteHardbouncesApiResponse> DeleteHardbouncesAsync(Option<DeleteHardbounces> deleteHardbounces = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete hardbounces
        /// </summary>
        /// <remarks>
        /// Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
        /// </remarks>
        /// <param name="deleteHardbounces">values to delete hardbounces (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteHardbouncesApiResponse"/>?&gt;</returns>
        Task<IDeleteHardbouncesApiResponse?> DeleteHardbouncesOrDefaultAsync(Option<DeleteHardbounces> deleteHardbounces = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an inactive email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSmtpTemplateApiResponse"/>&gt;</returns>
        Task<IDeleteSmtpTemplateApiResponse> DeleteSmtpTemplateAsync(long templateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an inactive email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSmtpTemplateApiResponse"/>?&gt;</returns>
        Task<IDeleteSmtpTemplateApiResponse?> DeleteSmtpTemplateOrDefaultAsync(long templateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get your transactional email activity aggregated over a period of time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAggregatedSmtpReportApiResponse"/>&gt;</returns>
        Task<IGetAggregatedSmtpReportApiResponse> GetAggregatedSmtpReportAsync(Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get your transactional email activity aggregated over a period of time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAggregatedSmtpReportApiResponse"/>?&gt;</returns>
        Task<IGetAggregatedSmtpReportApiResponse?> GetAggregatedSmtpReportOrDefaultAsync(Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Get the list of blocked domains
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedDomainsApiResponse"/>&gt;</returns>
        Task<IGetBlockedDomainsApiResponse> GetBlockedDomainsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of blocked domains
        /// </summary>
        /// <remarks>
        /// Get the list of blocked domains
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedDomainsApiResponse"/>?&gt;</returns>
        Task<IGetBlockedDomainsApiResponse?> GetBlockedDomainsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all your transactional email activity (unaggregated events)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">Number limitation for the result returned (optional, default to 50)</param>
        /// <param name="offset">Beginning point in the list to retrieve from. (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="email">Filter the report for a specific email addresses (optional)</param>
        /// <param name="varEvent">Filter the report for a specific event type (optional)</param>
        /// <param name="tags">Filter the report for tags (serialized and urlencoded array) (optional)</param>
        /// <param name="messageId">Filter on a specific message id (optional)</param>
        /// <param name="templateId">Filter on a specific template id (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailEventReportApiResponse"/>&gt;</returns>
        Task<IGetEmailEventReportApiResponse> GetEmailEventReportAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> email = default, Option<string> varEvent = default, Option<string> tags = default, Option<string> messageId = default, Option<long> templateId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all your transactional email activity (unaggregated events)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="limit">Number limitation for the result returned (optional, default to 50)</param>
        /// <param name="offset">Beginning point in the list to retrieve from. (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="email">Filter the report for a specific email addresses (optional)</param>
        /// <param name="varEvent">Filter the report for a specific event type (optional)</param>
        /// <param name="tags">Filter the report for tags (serialized and urlencoded array) (optional)</param>
        /// <param name="messageId">Filter on a specific message id (optional)</param>
        /// <param name="templateId">Filter on a specific template id (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailEventReportApiResponse"/>?&gt;</returns>
        Task<IGetEmailEventReportApiResponse?> GetEmailEventReportOrDefaultAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> email = default, Option<string> varEvent = default, Option<string> tags = default, Option<string> messageId = default, Option<long> templateId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get your transactional email activity aggregated per day
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">Number of documents returned per page (optional, default to 10)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpReportApiResponse"/>&gt;</returns>
        Task<IGetSmtpReportApiResponse> GetSmtpReportAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get your transactional email activity aggregated per day
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="limit">Number of documents returned per page (optional, default to 10)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpReportApiResponse"/>?&gt;</returns>
        Task<IGetSmtpReportApiResponse?> GetSmtpReportOrDefaultAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns the template information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplateApiResponse"/>&gt;</returns>
        Task<IGetSmtpTemplateApiResponse> GetSmtpTemplateAsync(long templateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns the template information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplateApiResponse"/>?&gt;</returns>
        Task<IGetSmtpTemplateApiResponse?> GetSmtpTemplateOrDefaultAsync(long templateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of email templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateStatus">Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document in the page (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplatesApiResponse"/>&gt;</returns>
        Task<IGetSmtpTemplatesApiResponse> GetSmtpTemplatesAsync(Option<bool> templateStatus = default, Option<long> limit = default, Option<long> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of email templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="templateStatus">Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document in the page (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplatesApiResponse"/>?&gt;</returns>
        Task<IGetSmtpTemplatesApiResponse?> GetSmtpTemplatesOrDefaultAsync(Option<bool> templateStatus = default, Option<long> limit = default, Option<long> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of blocked or unsubscribed transactional contacts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="senders">Comma separated list of emails of the senders from which contacts are blocked or unsubscribed (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacBlockedContactsApiResponse"/>&gt;</returns>
        Task<IGetTransacBlockedContactsApiResponse> GetTransacBlockedContactsAsync(Option<string> startDate = default, Option<string> endDate = default, Option<long> limit = default, Option<long> offset = default, Option<List<string>> senders = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of blocked or unsubscribed transactional contacts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="senders">Comma separated list of emails of the senders from which contacts are blocked or unsubscribed (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacBlockedContactsApiResponse"/>?&gt;</returns>
        Task<IGetTransacBlockedContactsApiResponse?> GetTransacBlockedContactsOrDefaultAsync(Option<string> startDate = default, Option<string> endDate = default, Option<long> limit = default, Option<long> offset = default, Option<List<string>> senders = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the personalized content of a sent transactional email
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uuid">Unique id of the transactional email that has been sent to a particular contact</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailContentApiResponse"/>&gt;</returns>
        Task<IGetTransacEmailContentApiResponse> GetTransacEmailContentAsync(string uuid, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the personalized content of a sent transactional email
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="uuid">Unique id of the transactional email that has been sent to a particular contact</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailContentApiResponse"/>?&gt;</returns>
        Task<IGetTransacEmailContentApiResponse?> GetTransacEmailContentOrDefaultAsync(string uuid, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of transactional emails on the basis of allowed filters
        /// </summary>
        /// <remarks>
        /// This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="email">Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent. (optional)</param>
        /// <param name="templateId">Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email. (optional)</param>
        /// <param name="messageId">Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent. (optional)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailsListApiResponse"/>&gt;</returns>
        Task<IGetTransacEmailsListApiResponse> GetTransacEmailsListAsync(Option<string> email = default, Option<long> templateId = default, Option<string> messageId = default, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the list of transactional emails on the basis of allowed filters
        /// </summary>
        /// <remarks>
        /// This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
        /// </remarks>
        /// <param name="email">Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent. (optional)</param>
        /// <param name="templateId">Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email. (optional)</param>
        /// <param name="messageId">Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent. (optional)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailsListApiResponse"/>?&gt;</returns>
        Task<IGetTransacEmailsListApiResponse?> GetTransacEmailsListOrDefaultAsync(Option<string> email = default, Option<long> templateId = default, Option<string> messageId = default, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a template
        /// </summary>
        /// <remarks>
        /// This endpoint is deprecated. Prefer v3/smtp/email instead.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTemplateApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<ISendTemplateApiResponse> SendTemplateAsync(long templateId, SendEmail sendEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a template
        /// </summary>
        /// <remarks>
        /// This endpoint is deprecated. Prefer v3/smtp/email instead.
        /// </remarks>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTemplateApiResponse"/>?&gt;</returns>
        [Obsolete]
        Task<ISendTemplateApiResponse?> SendTemplateOrDefaultAsync(long templateId, SendEmail sendEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a template to your test list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendTestEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestTemplateApiResponse"/>&gt;</returns>
        Task<ISendTestTemplateApiResponse> SendTestTemplateAsync(long templateId, SendTestEmail sendTestEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a template to your test list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendTestEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestTemplateApiResponse"/>?&gt;</returns>
        Task<ISendTestTemplateApiResponse?> SendTestTemplateOrDefaultAsync(long templateId, SendTestEmail sendTestEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a transactional email
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendSmtpEmail">Values to send a transactional email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTransacEmailApiResponse"/>&gt;</returns>
        Task<ISendTransacEmailApiResponse> SendTransacEmailAsync(SendSmtpEmail sendSmtpEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a transactional email
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="sendSmtpEmail">Values to send a transactional email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTransacEmailApiResponse"/>?&gt;</returns>
        Task<ISendTransacEmailApiResponse?> SendTransacEmailOrDefaultAsync(SendSmtpEmail sendSmtpEmail, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unblock or resubscribe a transactional contact
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="email">contact email (urlencoded) to unblock.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpBlockedContactsEmailDeleteApiResponse"/>&gt;</returns>
        Task<ISmtpBlockedContactsEmailDeleteApiResponse> SmtpBlockedContactsEmailDeleteAsync(string email, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unblock or resubscribe a transactional contact
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="email">contact email (urlencoded) to unblock.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpBlockedContactsEmailDeleteApiResponse"/>?&gt;</returns>
        Task<ISmtpBlockedContactsEmailDeleteApiResponse?> SmtpBlockedContactsEmailDeleteOrDefaultAsync(string email, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an SMTP transactional log
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">MessageId of the transactional log to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpLogMessageIdDeleteApiResponse"/>&gt;</returns>
        Task<ISmtpLogMessageIdDeleteApiResponse> SmtpLogMessageIdDeleteAsync(string messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an SMTP transactional log
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="messageId">MessageId of the transactional log to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpLogMessageIdDeleteApiResponse"/>?&gt;</returns>
        Task<ISmtpLogMessageIdDeleteApiResponse?> SmtpLogMessageIdDeleteOrDefaultAsync(string messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpTemplateApiResponse"/>&gt;</returns>
        Task<IUpdateSmtpTemplateApiResponse> UpdateSmtpTemplateAsync(long templateId, UpdateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an email template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="templateId">id of the template</param>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpTemplateApiResponse"/>?&gt;</returns>
        Task<IUpdateSmtpTemplateApiResponse?> UpdateSmtpTemplateOrDefaultAsync(long templateId, UpdateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IBlockNewDomainApiResponse"/>
    /// </summary>
    public interface IBlockNewDomainApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="ICreateSmtpTemplateApiResponse"/>
    /// </summary>
    public interface ICreateSmtpTemplateApiResponse : BrevoDotNet.Client.IApiResponse, ICreated<BrevoDotNet.Model.CreateModel?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteBlockedDomainApiResponse"/>
    /// </summary>
    public interface IDeleteBlockedDomainApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteHardbouncesApiResponse"/>
    /// </summary>
    public interface IDeleteHardbouncesApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteSmtpTemplateApiResponse"/>
    /// </summary>
    public interface IDeleteSmtpTemplateApiResponse : BrevoDotNet.Client.IApiResponse, INotFound<BrevoDotNet.Model.ErrorModel?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetAggregatedSmtpReportApiResponse"/>
    /// </summary>
    public interface IGetAggregatedSmtpReportApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetAggregatedReport?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetBlockedDomainsApiResponse"/>
    /// </summary>
    public interface IGetBlockedDomainsApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetBlockedDomains?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailEventReportApiResponse"/>
    /// </summary>
    public interface IGetEmailEventReportApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetEmailEventReport?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetSmtpReportApiResponse"/>
    /// </summary>
    public interface IGetSmtpReportApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetReports?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetSmtpTemplateApiResponse"/>
    /// </summary>
    public interface IGetSmtpTemplateApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetSmtpTemplateOverview?>, INotFound<BrevoDotNet.Model.ErrorModel?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetSmtpTemplatesApiResponse"/>
    /// </summary>
    public interface IGetSmtpTemplatesApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetSmtpTemplates?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetTransacBlockedContactsApiResponse"/>
    /// </summary>
    public interface IGetTransacBlockedContactsApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetTransacBlockedContacts?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetTransacEmailContentApiResponse"/>
    /// </summary>
    public interface IGetTransacEmailContentApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetTransacEmailContent?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTransacEmailsListApiResponse"/>
    /// </summary>
    public interface IGetTransacEmailsListApiResponse : BrevoDotNet.Client.IApiResponse, IOk<BrevoDotNet.Model.GetTransacEmailsList?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="ISendTemplateApiResponse"/>
    /// </summary>
    public interface ISendTemplateApiResponse : BrevoDotNet.Client.IApiResponse, ICreated<BrevoDotNet.Model.SendTemplateEmail?>, IBadRequest<BrevoDotNet.Model.PostSendFailed?>, INotFound<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISendTestTemplateApiResponse"/>
    /// </summary>
    public interface ISendTestTemplateApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.PostSendFailed?>, INotFound<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISendTransacEmailApiResponse"/>
    /// </summary>
    public interface ISendTransacEmailApiResponse : BrevoDotNet.Client.IApiResponse, ICreated<BrevoDotNet.Model.CreateSmtpEmail?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="ISmtpBlockedContactsEmailDeleteApiResponse"/>
    /// </summary>
    public interface ISmtpBlockedContactsEmailDeleteApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.ErrorModel?>, INotFound<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISmtpLogMessageIdDeleteApiResponse"/>
    /// </summary>
    public interface ISmtpLogMessageIdDeleteApiResponse : BrevoDotNet.Client.IApiResponse, INotFound<BrevoDotNet.Model.ErrorModel?>, IBadRequest<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateSmtpTemplateApiResponse"/>
    /// </summary>
    public interface IUpdateSmtpTemplateApiResponse : BrevoDotNet.Client.IApiResponse, IBadRequest<BrevoDotNet.Model.ErrorModel?>, INotFound<BrevoDotNet.Model.ErrorModel?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class SMTPApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBlockNewDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBlockNewDomain;

        internal void ExecuteOnBlockNewDomain(SMTPApi.BlockNewDomainApiResponse apiResponse)
        {
            OnBlockNewDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBlockNewDomain(Exception exception)
        {
            OnErrorBlockNewDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateSmtpTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateSmtpTemplate;

        internal void ExecuteOnCreateSmtpTemplate(SMTPApi.CreateSmtpTemplateApiResponse apiResponse)
        {
            OnCreateSmtpTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateSmtpTemplate(Exception exception)
        {
            OnErrorCreateSmtpTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteBlockedDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteBlockedDomain;

        internal void ExecuteOnDeleteBlockedDomain(SMTPApi.DeleteBlockedDomainApiResponse apiResponse)
        {
            OnDeleteBlockedDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteBlockedDomain(Exception exception)
        {
            OnErrorDeleteBlockedDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteHardbounces;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteHardbounces;

        internal void ExecuteOnDeleteHardbounces(SMTPApi.DeleteHardbouncesApiResponse apiResponse)
        {
            OnDeleteHardbounces?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteHardbounces(Exception exception)
        {
            OnErrorDeleteHardbounces?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSmtpTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSmtpTemplate;

        internal void ExecuteOnDeleteSmtpTemplate(SMTPApi.DeleteSmtpTemplateApiResponse apiResponse)
        {
            OnDeleteSmtpTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSmtpTemplate(Exception exception)
        {
            OnErrorDeleteSmtpTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAggregatedSmtpReport;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAggregatedSmtpReport;

        internal void ExecuteOnGetAggregatedSmtpReport(SMTPApi.GetAggregatedSmtpReportApiResponse apiResponse)
        {
            OnGetAggregatedSmtpReport?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAggregatedSmtpReport(Exception exception)
        {
            OnErrorGetAggregatedSmtpReport?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBlockedDomains;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBlockedDomains;

        internal void ExecuteOnGetBlockedDomains(SMTPApi.GetBlockedDomainsApiResponse apiResponse)
        {
            OnGetBlockedDomains?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBlockedDomains(Exception exception)
        {
            OnErrorGetBlockedDomains?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetEmailEventReport;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetEmailEventReport;

        internal void ExecuteOnGetEmailEventReport(SMTPApi.GetEmailEventReportApiResponse apiResponse)
        {
            OnGetEmailEventReport?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailEventReport(Exception exception)
        {
            OnErrorGetEmailEventReport?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSmtpReport;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSmtpReport;

        internal void ExecuteOnGetSmtpReport(SMTPApi.GetSmtpReportApiResponse apiResponse)
        {
            OnGetSmtpReport?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSmtpReport(Exception exception)
        {
            OnErrorGetSmtpReport?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSmtpTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSmtpTemplate;

        internal void ExecuteOnGetSmtpTemplate(SMTPApi.GetSmtpTemplateApiResponse apiResponse)
        {
            OnGetSmtpTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSmtpTemplate(Exception exception)
        {
            OnErrorGetSmtpTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSmtpTemplates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSmtpTemplates;

        internal void ExecuteOnGetSmtpTemplates(SMTPApi.GetSmtpTemplatesApiResponse apiResponse)
        {
            OnGetSmtpTemplates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSmtpTemplates(Exception exception)
        {
            OnErrorGetSmtpTemplates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTransacBlockedContacts;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTransacBlockedContacts;

        internal void ExecuteOnGetTransacBlockedContacts(SMTPApi.GetTransacBlockedContactsApiResponse apiResponse)
        {
            OnGetTransacBlockedContacts?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTransacBlockedContacts(Exception exception)
        {
            OnErrorGetTransacBlockedContacts?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTransacEmailContent;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTransacEmailContent;

        internal void ExecuteOnGetTransacEmailContent(SMTPApi.GetTransacEmailContentApiResponse apiResponse)
        {
            OnGetTransacEmailContent?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTransacEmailContent(Exception exception)
        {
            OnErrorGetTransacEmailContent?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTransacEmailsList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTransacEmailsList;

        internal void ExecuteOnGetTransacEmailsList(SMTPApi.GetTransacEmailsListApiResponse apiResponse)
        {
            OnGetTransacEmailsList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTransacEmailsList(Exception exception)
        {
            OnErrorGetTransacEmailsList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendTemplate;

        internal void ExecuteOnSendTemplate(SMTPApi.SendTemplateApiResponse apiResponse)
        {
            OnSendTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendTemplate(Exception exception)
        {
            OnErrorSendTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendTestTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendTestTemplate;

        internal void ExecuteOnSendTestTemplate(SMTPApi.SendTestTemplateApiResponse apiResponse)
        {
            OnSendTestTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendTestTemplate(Exception exception)
        {
            OnErrorSendTestTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendTransacEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendTransacEmail;

        internal void ExecuteOnSendTransacEmail(SMTPApi.SendTransacEmailApiResponse apiResponse)
        {
            OnSendTransacEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendTransacEmail(Exception exception)
        {
            OnErrorSendTransacEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSmtpBlockedContactsEmailDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSmtpBlockedContactsEmailDelete;

        internal void ExecuteOnSmtpBlockedContactsEmailDelete(SMTPApi.SmtpBlockedContactsEmailDeleteApiResponse apiResponse)
        {
            OnSmtpBlockedContactsEmailDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSmtpBlockedContactsEmailDelete(Exception exception)
        {
            OnErrorSmtpBlockedContactsEmailDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSmtpLogMessageIdDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSmtpLogMessageIdDelete;

        internal void ExecuteOnSmtpLogMessageIdDelete(SMTPApi.SmtpLogMessageIdDeleteApiResponse apiResponse)
        {
            OnSmtpLogMessageIdDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSmtpLogMessageIdDelete(Exception exception)
        {
            OnErrorSmtpLogMessageIdDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateSmtpTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateSmtpTemplate;

        internal void ExecuteOnUpdateSmtpTemplate(SMTPApi.UpdateSmtpTemplateApiResponse apiResponse)
        {
            OnUpdateSmtpTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateSmtpTemplate(Exception exception)
        {
            OnErrorUpdateSmtpTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class SMTPApi : ISMTPApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<SMTPApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public SMTPApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SMTPApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SMTPApi(ILogger<SMTPApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, SMTPApiEvents sMTPApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<SMTPApi>();
            HttpClient = httpClient;
            Events = sMTPApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatBlockNewDomain(BlockDomain blockDomain);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="blockDomain"></param>
        /// <returns></returns>
        private void ValidateBlockNewDomain(BlockDomain blockDomain)
        {
            if (blockDomain == null)
                throw new ArgumentNullException(nameof(blockDomain));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="blockDomain"></param>
        private void AfterBlockNewDomainDefaultImplementation(IBlockNewDomainApiResponse apiResponseLocalVar, BlockDomain blockDomain)
        {
            bool suppressDefaultLog = false;
            AfterBlockNewDomain(ref suppressDefaultLog, apiResponseLocalVar, blockDomain);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="blockDomain"></param>
        partial void AfterBlockNewDomain(ref bool suppressDefaultLog, IBlockNewDomainApiResponse apiResponseLocalVar, BlockDomain blockDomain);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="blockDomain"></param>
        private void OnErrorBlockNewDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, BlockDomain blockDomain)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBlockNewDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, blockDomain);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="blockDomain"></param>
        partial void OnErrorBlockNewDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, BlockDomain blockDomain);

        /// <summary>
        /// Add a new domain to the list of blocked domains Blocks a new domain in order to avoid messages being sent to the same
        /// </summary>
        /// <param name="blockDomain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBlockNewDomainApiResponse"/>&gt;</returns>
        public async Task<IBlockNewDomainApiResponse?> BlockNewDomainOrDefaultAsync(BlockDomain blockDomain, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BlockNewDomainAsync(blockDomain, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add a new domain to the list of blocked domains Blocks a new domain in order to avoid messages being sent to the same
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="blockDomain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBlockNewDomainApiResponse"/>&gt;</returns>
        public async Task<IBlockNewDomainApiResponse> BlockNewDomainAsync(BlockDomain blockDomain, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBlockNewDomain(blockDomain);

                FormatBlockNewDomain(blockDomain);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/blockedDomains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/blockedDomains");

                    httpRequestMessageLocalVar.Content = (blockDomain as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(blockDomain, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BlockNewDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BlockNewDomainApiResponse>();

                        BlockNewDomainApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/blockedDomains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBlockNewDomainDefaultImplementation(apiResponseLocalVar, blockDomain);

                        Events.ExecuteOnBlockNewDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBlockNewDomainDefaultImplementation(e, "/smtp/blockedDomains", uriBuilderLocalVar.Path, blockDomain);
                Events.ExecuteOnErrorBlockNewDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BlockNewDomainApiResponse"/>
        /// </summary>
        public partial class BlockNewDomainApiResponse : BrevoDotNet.Client.ApiResponse, IBlockNewDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BlockNewDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BlockNewDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BlockNewDomainApiResponse(ILogger<BlockNewDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateSmtpTemplate(CreateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="smtpTemplate"></param>
        /// <returns></returns>
        private void ValidateCreateSmtpTemplate(CreateSmtpTemplate smtpTemplate)
        {
            if (smtpTemplate == null)
                throw new ArgumentNullException(nameof(smtpTemplate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="smtpTemplate"></param>
        private void AfterCreateSmtpTemplateDefaultImplementation(ICreateSmtpTemplateApiResponse apiResponseLocalVar, CreateSmtpTemplate smtpTemplate)
        {
            bool suppressDefaultLog = false;
            AfterCreateSmtpTemplate(ref suppressDefaultLog, apiResponseLocalVar, smtpTemplate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="smtpTemplate"></param>
        partial void AfterCreateSmtpTemplate(ref bool suppressDefaultLog, ICreateSmtpTemplateApiResponse apiResponseLocalVar, CreateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="smtpTemplate"></param>
        private void OnErrorCreateSmtpTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateSmtpTemplate smtpTemplate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateSmtpTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, smtpTemplate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="smtpTemplate"></param>
        partial void OnErrorCreateSmtpTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Create an email template 
        /// </summary>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<ICreateSmtpTemplateApiResponse?> CreateSmtpTemplateOrDefaultAsync(CreateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateSmtpTemplateAsync(smtpTemplate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an email template 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<ICreateSmtpTemplateApiResponse> CreateSmtpTemplateAsync(CreateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateSmtpTemplate(smtpTemplate);

                FormatCreateSmtpTemplate(smtpTemplate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates");

                    httpRequestMessageLocalVar.Content = (smtpTemplate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(smtpTemplate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateSmtpTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateSmtpTemplateApiResponse>();

                        CreateSmtpTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateSmtpTemplateDefaultImplementation(apiResponseLocalVar, smtpTemplate);

                        Events.ExecuteOnCreateSmtpTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateSmtpTemplateDefaultImplementation(e, "/smtp/templates", uriBuilderLocalVar.Path, smtpTemplate);
                Events.ExecuteOnErrorCreateSmtpTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateSmtpTemplateApiResponse"/>
        /// </summary>
        public partial class CreateSmtpTemplateApiResponse : BrevoDotNet.Client.ApiResponse, ICreateSmtpTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateSmtpTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateSmtpTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateSmtpTemplateApiResponse(ILogger<CreateSmtpTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.CreateModel? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.CreateModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out BrevoDotNet.Model.CreateModel? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteBlockedDomain(ref string domain);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="domain"></param>
        /// <returns></returns>
        private void ValidateDeleteBlockedDomain(string domain)
        {
            if (domain == null)
                throw new ArgumentNullException(nameof(domain));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        private void AfterDeleteBlockedDomainDefaultImplementation(IDeleteBlockedDomainApiResponse apiResponseLocalVar, string domain)
        {
            bool suppressDefaultLog = false;
            AfterDeleteBlockedDomain(ref suppressDefaultLog, apiResponseLocalVar, domain);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        partial void AfterDeleteBlockedDomain(ref bool suppressDefaultLog, IDeleteBlockedDomainApiResponse apiResponseLocalVar, string domain);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        private void OnErrorDeleteBlockedDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteBlockedDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, domain);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        partial void OnErrorDeleteBlockedDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain);

        /// <summary>
        /// Unblock an existing domain from the list of blocked domains Unblocks an existing domain from the list of blocked domains
        /// </summary>
        /// <param name="domain">The name of the domain to be deleted</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBlockedDomainApiResponse"/>&gt;</returns>
        public async Task<IDeleteBlockedDomainApiResponse?> DeleteBlockedDomainOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteBlockedDomainAsync(domain, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Unblock an existing domain from the list of blocked domains Unblocks an existing domain from the list of blocked domains
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The name of the domain to be deleted</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBlockedDomainApiResponse"/>&gt;</returns>
        public async Task<IDeleteBlockedDomainApiResponse> DeleteBlockedDomainAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteBlockedDomain(domain);

                FormatDeleteBlockedDomain(ref domain);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/blockedDomains/{domain}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/blockedDomains/{domain}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdomain%7D", Uri.EscapeDataString(domain.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteBlockedDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteBlockedDomainApiResponse>();

                        DeleteBlockedDomainApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/blockedDomains/{domain}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteBlockedDomainDefaultImplementation(apiResponseLocalVar, domain);

                        Events.ExecuteOnDeleteBlockedDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteBlockedDomainDefaultImplementation(e, "/smtp/blockedDomains/{domain}", uriBuilderLocalVar.Path, domain);
                Events.ExecuteOnErrorDeleteBlockedDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteBlockedDomainApiResponse"/>
        /// </summary>
        public partial class DeleteBlockedDomainApiResponse : BrevoDotNet.Client.ApiResponse, IDeleteBlockedDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteBlockedDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteBlockedDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBlockedDomainApiResponse(ILogger<DeleteBlockedDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteHardbounces(Option<DeleteHardbounces> deleteHardbounces);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deleteHardbounces"></param>
        /// <returns></returns>
        private void ValidateDeleteHardbounces(Option<DeleteHardbounces> deleteHardbounces)
        {
            if (deleteHardbounces.IsSet && deleteHardbounces.Value == null)
                throw new ArgumentNullException(nameof(deleteHardbounces));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deleteHardbounces"></param>
        private void AfterDeleteHardbouncesDefaultImplementation(IDeleteHardbouncesApiResponse apiResponseLocalVar, Option<DeleteHardbounces> deleteHardbounces)
        {
            bool suppressDefaultLog = false;
            AfterDeleteHardbounces(ref suppressDefaultLog, apiResponseLocalVar, deleteHardbounces);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deleteHardbounces"></param>
        partial void AfterDeleteHardbounces(ref bool suppressDefaultLog, IDeleteHardbouncesApiResponse apiResponseLocalVar, Option<DeleteHardbounces> deleteHardbounces);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deleteHardbounces"></param>
        private void OnErrorDeleteHardbouncesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<DeleteHardbounces> deleteHardbounces)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteHardbounces(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deleteHardbounces);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deleteHardbounces"></param>
        partial void OnErrorDeleteHardbounces(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<DeleteHardbounces> deleteHardbounces);

        /// <summary>
        /// Delete hardbounces Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
        /// </summary>
        /// <param name="deleteHardbounces">values to delete hardbounces (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteHardbouncesApiResponse"/>&gt;</returns>
        public async Task<IDeleteHardbouncesApiResponse?> DeleteHardbouncesOrDefaultAsync(Option<DeleteHardbounces> deleteHardbounces = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteHardbouncesAsync(deleteHardbounces, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete hardbounces Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteHardbounces">values to delete hardbounces (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteHardbouncesApiResponse"/>&gt;</returns>
        public async Task<IDeleteHardbouncesApiResponse> DeleteHardbouncesAsync(Option<DeleteHardbounces> deleteHardbounces = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteHardbounces(deleteHardbounces);

                FormatDeleteHardbounces(deleteHardbounces);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/deleteHardbounces"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/deleteHardbounces");

                    if (deleteHardbounces.IsSet)
                        httpRequestMessageLocalVar.Content = (deleteHardbounces.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(deleteHardbounces.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteHardbouncesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteHardbouncesApiResponse>();

                        DeleteHardbouncesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/deleteHardbounces", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteHardbouncesDefaultImplementation(apiResponseLocalVar, deleteHardbounces);

                        Events.ExecuteOnDeleteHardbounces(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteHardbouncesDefaultImplementation(e, "/smtp/deleteHardbounces", uriBuilderLocalVar.Path, deleteHardbounces);
                Events.ExecuteOnErrorDeleteHardbounces(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteHardbouncesApiResponse"/>
        /// </summary>
        public partial class DeleteHardbouncesApiResponse : BrevoDotNet.Client.ApiResponse, IDeleteHardbouncesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteHardbouncesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteHardbouncesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteHardbouncesApiResponse(ILogger<DeleteHardbouncesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteSmtpTemplate(ref long templateId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        private void AfterDeleteSmtpTemplateDefaultImplementation(IDeleteSmtpTemplateApiResponse apiResponseLocalVar, long templateId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSmtpTemplate(ref suppressDefaultLog, apiResponseLocalVar, templateId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        partial void AfterDeleteSmtpTemplate(ref bool suppressDefaultLog, IDeleteSmtpTemplateApiResponse apiResponseLocalVar, long templateId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        private void OnErrorDeleteSmtpTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSmtpTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        partial void OnErrorDeleteSmtpTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId);

        /// <summary>
        /// Delete an inactive email template 
        /// </summary>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSmtpTemplateApiResponse?> DeleteSmtpTemplateOrDefaultAsync(long templateId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSmtpTemplateAsync(templateId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an inactive email template 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSmtpTemplateApiResponse> DeleteSmtpTemplateAsync(long templateId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteSmtpTemplate(ref templateId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates/{templateId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates/{templateId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtemplateId%7D", Uri.EscapeDataString(templateId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteSmtpTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSmtpTemplateApiResponse>();

                        DeleteSmtpTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates/{templateId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteSmtpTemplateDefaultImplementation(apiResponseLocalVar, templateId);

                        Events.ExecuteOnDeleteSmtpTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSmtpTemplateDefaultImplementation(e, "/smtp/templates/{templateId}", uriBuilderLocalVar.Path, templateId);
                Events.ExecuteOnErrorDeleteSmtpTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSmtpTemplateApiResponse"/>
        /// </summary>
        public partial class DeleteSmtpTemplateApiResponse : BrevoDotNet.Client.ApiResponse, IDeleteSmtpTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSmtpTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSmtpTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSmtpTemplateApiResponse(ILogger<DeleteSmtpTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAggregatedSmtpReport(ref Option<string> startDate, ref Option<string> endDate, ref Option<int> days, ref Option<string> tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateGetAggregatedSmtpReport(Option<string> startDate, Option<string> endDate, Option<string> tag)
        {
            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate));

            if (endDate.IsSet && endDate.Value == null)
                throw new ArgumentNullException(nameof(endDate));

            if (tag.IsSet && tag.Value == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        private void AfterGetAggregatedSmtpReportDefaultImplementation(IGetAggregatedSmtpReportApiResponse apiResponseLocalVar, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag)
        {
            bool suppressDefaultLog = false;
            AfterGetAggregatedSmtpReport(ref suppressDefaultLog, apiResponseLocalVar, startDate, endDate, days, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        partial void AfterGetAggregatedSmtpReport(ref bool suppressDefaultLog, IGetAggregatedSmtpReportApiResponse apiResponseLocalVar, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        private void OnErrorGetAggregatedSmtpReportDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAggregatedSmtpReport(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startDate, endDate, days, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        partial void OnErrorGetAggregatedSmtpReport(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag);

        /// <summary>
        /// Get your transactional email activity aggregated over a period of time 
        /// </summary>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAggregatedSmtpReportApiResponse"/>&gt;</returns>
        public async Task<IGetAggregatedSmtpReportApiResponse?> GetAggregatedSmtpReportOrDefaultAsync(Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAggregatedSmtpReportAsync(startDate, endDate, days, tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get your transactional email activity aggregated over a period of time 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAggregatedSmtpReportApiResponse"/>&gt;</returns>
        public async Task<IGetAggregatedSmtpReportApiResponse> GetAggregatedSmtpReportAsync(Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAggregatedSmtpReport(startDate, endDate, tag);

                FormatGetAggregatedSmtpReport(ref startDate, ref endDate, ref days, ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/statistics/aggregatedReport"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/statistics/aggregatedReport");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (days.IsSet)
                        parseQueryStringLocalVar["days"] = ClientUtils.ParameterToString(days.Value);

                    if (tag.IsSet)
                        parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetAggregatedSmtpReportApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAggregatedSmtpReportApiResponse>();

                        GetAggregatedSmtpReportApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/statistics/aggregatedReport", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAggregatedSmtpReportDefaultImplementation(apiResponseLocalVar, startDate, endDate, days, tag);

                        Events.ExecuteOnGetAggregatedSmtpReport(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAggregatedSmtpReportDefaultImplementation(e, "/smtp/statistics/aggregatedReport", uriBuilderLocalVar.Path, startDate, endDate, days, tag);
                Events.ExecuteOnErrorGetAggregatedSmtpReport(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAggregatedSmtpReportApiResponse"/>
        /// </summary>
        public partial class GetAggregatedSmtpReportApiResponse : BrevoDotNet.Client.ApiResponse, IGetAggregatedSmtpReportApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAggregatedSmtpReportApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAggregatedSmtpReportApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAggregatedSmtpReportApiResponse(ILogger<GetAggregatedSmtpReportApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetAggregatedReport? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetAggregatedReport>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetAggregatedReport? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetBlockedDomainsDefaultImplementation(IGetBlockedDomainsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetBlockedDomains(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetBlockedDomains(ref bool suppressDefaultLog, IGetBlockedDomainsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetBlockedDomainsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBlockedDomains(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetBlockedDomains(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get the list of blocked domains Get the list of blocked domains
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetBlockedDomainsApiResponse?> GetBlockedDomainsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBlockedDomainsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the list of blocked domains Get the list of blocked domains
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetBlockedDomainsApiResponse> GetBlockedDomainsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/blockedDomains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/blockedDomains");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetBlockedDomainsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBlockedDomainsApiResponse>();

                        GetBlockedDomainsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/blockedDomains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetBlockedDomainsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetBlockedDomains(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBlockedDomainsDefaultImplementation(e, "/smtp/blockedDomains", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetBlockedDomains(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBlockedDomainsApiResponse"/>
        /// </summary>
        public partial class GetBlockedDomainsApiResponse : BrevoDotNet.Client.ApiResponse, IGetBlockedDomainsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBlockedDomainsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBlockedDomainsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBlockedDomainsApiResponse(ILogger<GetBlockedDomainsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetBlockedDomains? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetBlockedDomains>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetBlockedDomains? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailEventReport(ref Option<long> limit, ref Option<long> offset, ref Option<string> startDate, ref Option<string> endDate, ref Option<int> days, ref Option<string> email, ref Option<string> varEvent, ref Option<string> tags, ref Option<string> messageId, ref Option<long> templateId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="email"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <param name="messageId"></param>
        /// <returns></returns>
        private void ValidateGetEmailEventReport(Option<string> startDate, Option<string> endDate, Option<string> email, Option<string> varEvent, Option<string> tags, Option<string> messageId)
        {
            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate));

            if (endDate.IsSet && endDate.Value == null)
                throw new ArgumentNullException(nameof(endDate));

            if (email.IsSet && email.Value == null)
                throw new ArgumentNullException(nameof(email));

            if (varEvent.IsSet && varEvent.Value == null)
                throw new ArgumentNullException(nameof(varEvent));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (messageId.IsSet && messageId.Value == null)
                throw new ArgumentNullException(nameof(messageId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="email"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <param name="messageId"></param>
        /// <param name="templateId"></param>
        private void AfterGetEmailEventReportDefaultImplementation(IGetEmailEventReportApiResponse apiResponseLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> email, Option<string> varEvent, Option<string> tags, Option<string> messageId, Option<long> templateId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailEventReport(ref suppressDefaultLog, apiResponseLocalVar, limit, offset, startDate, endDate, days, email, varEvent, tags, messageId, templateId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="email"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <param name="messageId"></param>
        /// <param name="templateId"></param>
        partial void AfterGetEmailEventReport(ref bool suppressDefaultLog, IGetEmailEventReportApiResponse apiResponseLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> email, Option<string> varEvent, Option<string> tags, Option<string> messageId, Option<long> templateId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="email"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <param name="messageId"></param>
        /// <param name="templateId"></param>
        private void OnErrorGetEmailEventReportDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> email, Option<string> varEvent, Option<string> tags, Option<string> messageId, Option<long> templateId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailEventReport(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, limit, offset, startDate, endDate, days, email, varEvent, tags, messageId, templateId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="email"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <param name="messageId"></param>
        /// <param name="templateId"></param>
        partial void OnErrorGetEmailEventReport(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> email, Option<string> varEvent, Option<string> tags, Option<string> messageId, Option<long> templateId);

        /// <summary>
        /// Get all your transactional email activity (unaggregated events) 
        /// </summary>
        /// <param name="limit">Number limitation for the result returned (optional, default to 50)</param>
        /// <param name="offset">Beginning point in the list to retrieve from. (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="email">Filter the report for a specific email addresses (optional)</param>
        /// <param name="varEvent">Filter the report for a specific event type (optional)</param>
        /// <param name="tags">Filter the report for tags (serialized and urlencoded array) (optional)</param>
        /// <param name="messageId">Filter on a specific message id (optional)</param>
        /// <param name="templateId">Filter on a specific template id (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailEventReportApiResponse"/>&gt;</returns>
        public async Task<IGetEmailEventReportApiResponse?> GetEmailEventReportOrDefaultAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> email = default, Option<string> varEvent = default, Option<string> tags = default, Option<string> messageId = default, Option<long> templateId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailEventReportAsync(limit, offset, startDate, endDate, days, email, varEvent, tags, messageId, templateId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all your transactional email activity (unaggregated events) 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">Number limitation for the result returned (optional, default to 50)</param>
        /// <param name="offset">Beginning point in the list to retrieve from. (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="email">Filter the report for a specific email addresses (optional)</param>
        /// <param name="varEvent">Filter the report for a specific event type (optional)</param>
        /// <param name="tags">Filter the report for tags (serialized and urlencoded array) (optional)</param>
        /// <param name="messageId">Filter on a specific message id (optional)</param>
        /// <param name="templateId">Filter on a specific template id (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailEventReportApiResponse"/>&gt;</returns>
        public async Task<IGetEmailEventReportApiResponse> GetEmailEventReportAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> email = default, Option<string> varEvent = default, Option<string> tags = default, Option<string> messageId = default, Option<long> templateId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailEventReport(startDate, endDate, email, varEvent, tags, messageId);

                FormatGetEmailEventReport(ref limit, ref offset, ref startDate, ref endDate, ref days, ref email, ref varEvent, ref tags, ref messageId, ref templateId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/statistics/events"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/statistics/events");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (days.IsSet)
                        parseQueryStringLocalVar["days"] = ClientUtils.ParameterToString(days.Value);

                    if (email.IsSet)
                        parseQueryStringLocalVar["email"] = ClientUtils.ParameterToString(email.Value);

                    if (varEvent.IsSet)
                        parseQueryStringLocalVar["event"] = ClientUtils.ParameterToString(varEvent.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (messageId.IsSet)
                        parseQueryStringLocalVar["messageId"] = ClientUtils.ParameterToString(messageId.Value);

                    if (templateId.IsSet)
                        parseQueryStringLocalVar["templateId"] = ClientUtils.ParameterToString(templateId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetEmailEventReportApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailEventReportApiResponse>();

                        GetEmailEventReportApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/statistics/events", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailEventReportDefaultImplementation(apiResponseLocalVar, limit, offset, startDate, endDate, days, email, varEvent, tags, messageId, templateId);

                        Events.ExecuteOnGetEmailEventReport(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailEventReportDefaultImplementation(e, "/smtp/statistics/events", uriBuilderLocalVar.Path, limit, offset, startDate, endDate, days, email, varEvent, tags, messageId, templateId);
                Events.ExecuteOnErrorGetEmailEventReport(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailEventReportApiResponse"/>
        /// </summary>
        public partial class GetEmailEventReportApiResponse : BrevoDotNet.Client.ApiResponse, IGetEmailEventReportApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailEventReportApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailEventReportApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailEventReportApiResponse(ILogger<GetEmailEventReportApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetEmailEventReport? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetEmailEventReport>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetEmailEventReport? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSmtpReport(ref Option<long> limit, ref Option<long> offset, ref Option<string> startDate, ref Option<string> endDate, ref Option<int> days, ref Option<string> tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateGetSmtpReport(Option<string> startDate, Option<string> endDate, Option<string> tag)
        {
            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate));

            if (endDate.IsSet && endDate.Value == null)
                throw new ArgumentNullException(nameof(endDate));

            if (tag.IsSet && tag.Value == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        private void AfterGetSmtpReportDefaultImplementation(IGetSmtpReportApiResponse apiResponseLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag)
        {
            bool suppressDefaultLog = false;
            AfterGetSmtpReport(ref suppressDefaultLog, apiResponseLocalVar, limit, offset, startDate, endDate, days, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        partial void AfterGetSmtpReport(ref bool suppressDefaultLog, IGetSmtpReportApiResponse apiResponseLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        private void OnErrorGetSmtpReportDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSmtpReport(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, limit, offset, startDate, endDate, days, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="days"></param>
        /// <param name="tag"></param>
        partial void OnErrorGetSmtpReport(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> limit, Option<long> offset, Option<string> startDate, Option<string> endDate, Option<int> days, Option<string> tag);

        /// <summary>
        /// Get your transactional email activity aggregated per day 
        /// </summary>
        /// <param name="limit">Number of documents returned per page (optional, default to 10)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpReportApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpReportApiResponse?> GetSmtpReportOrDefaultAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSmtpReportAsync(limit, offset, startDate, endDate, days, tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get your transactional email activity aggregated per day 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">Number of documents returned per page (optional, default to 10)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD) (optional)</param>
        /// <param name="days">Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39; (optional)</param>
        /// <param name="tag">Tag of the emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpReportApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpReportApiResponse> GetSmtpReportAsync(Option<long> limit = default, Option<long> offset = default, Option<string> startDate = default, Option<string> endDate = default, Option<int> days = default, Option<string> tag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSmtpReport(startDate, endDate, tag);

                FormatGetSmtpReport(ref limit, ref offset, ref startDate, ref endDate, ref days, ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/statistics/reports"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/statistics/reports");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (days.IsSet)
                        parseQueryStringLocalVar["days"] = ClientUtils.ParameterToString(days.Value);

                    if (tag.IsSet)
                        parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSmtpReportApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSmtpReportApiResponse>();

                        GetSmtpReportApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/statistics/reports", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSmtpReportDefaultImplementation(apiResponseLocalVar, limit, offset, startDate, endDate, days, tag);

                        Events.ExecuteOnGetSmtpReport(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSmtpReportDefaultImplementation(e, "/smtp/statistics/reports", uriBuilderLocalVar.Path, limit, offset, startDate, endDate, days, tag);
                Events.ExecuteOnErrorGetSmtpReport(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSmtpReportApiResponse"/>
        /// </summary>
        public partial class GetSmtpReportApiResponse : BrevoDotNet.Client.ApiResponse, IGetSmtpReportApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSmtpReportApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSmtpReportApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSmtpReportApiResponse(ILogger<GetSmtpReportApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetReports? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetReports>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetReports? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSmtpTemplate(ref long templateId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        private void AfterGetSmtpTemplateDefaultImplementation(IGetSmtpTemplateApiResponse apiResponseLocalVar, long templateId)
        {
            bool suppressDefaultLog = false;
            AfterGetSmtpTemplate(ref suppressDefaultLog, apiResponseLocalVar, templateId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        partial void AfterGetSmtpTemplate(ref bool suppressDefaultLog, IGetSmtpTemplateApiResponse apiResponseLocalVar, long templateId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        private void OnErrorGetSmtpTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSmtpTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        partial void OnErrorGetSmtpTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId);

        /// <summary>
        /// Returns the template information 
        /// </summary>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpTemplateApiResponse?> GetSmtpTemplateOrDefaultAsync(long templateId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSmtpTemplateAsync(templateId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns the template information 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpTemplateApiResponse> GetSmtpTemplateAsync(long templateId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetSmtpTemplate(ref templateId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates/{templateId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates/{templateId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtemplateId%7D", Uri.EscapeDataString(templateId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSmtpTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSmtpTemplateApiResponse>();

                        GetSmtpTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates/{templateId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSmtpTemplateDefaultImplementation(apiResponseLocalVar, templateId);

                        Events.ExecuteOnGetSmtpTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSmtpTemplateDefaultImplementation(e, "/smtp/templates/{templateId}", uriBuilderLocalVar.Path, templateId);
                Events.ExecuteOnErrorGetSmtpTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSmtpTemplateApiResponse"/>
        /// </summary>
        public partial class GetSmtpTemplateApiResponse : BrevoDotNet.Client.ApiResponse, IGetSmtpTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSmtpTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSmtpTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSmtpTemplateApiResponse(ILogger<GetSmtpTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetSmtpTemplateOverview? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetSmtpTemplateOverview>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetSmtpTemplateOverview? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSmtpTemplates(ref Option<bool> templateStatus, ref Option<long> limit, ref Option<long> offset);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateStatus"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void AfterGetSmtpTemplatesDefaultImplementation(IGetSmtpTemplatesApiResponse apiResponseLocalVar, Option<bool> templateStatus, Option<long> limit, Option<long> offset)
        {
            bool suppressDefaultLog = false;
            AfterGetSmtpTemplates(ref suppressDefaultLog, apiResponseLocalVar, templateStatus, limit, offset);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateStatus"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void AfterGetSmtpTemplates(ref bool suppressDefaultLog, IGetSmtpTemplatesApiResponse apiResponseLocalVar, Option<bool> templateStatus, Option<long> limit, Option<long> offset);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateStatus"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void OnErrorGetSmtpTemplatesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> templateStatus, Option<long> limit, Option<long> offset)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSmtpTemplates(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateStatus, limit, offset);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateStatus"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void OnErrorGetSmtpTemplates(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> templateStatus, Option<long> limit, Option<long> offset);

        /// <summary>
        /// Get the list of email templates 
        /// </summary>
        /// <param name="templateStatus">Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document in the page (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplatesApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpTemplatesApiResponse?> GetSmtpTemplatesOrDefaultAsync(Option<bool> templateStatus = default, Option<long> limit = default, Option<long> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSmtpTemplatesAsync(templateStatus, limit, offset, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the list of email templates 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateStatus">Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document in the page (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpTemplatesApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpTemplatesApiResponse> GetSmtpTemplatesAsync(Option<bool> templateStatus = default, Option<long> limit = default, Option<long> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetSmtpTemplates(ref templateStatus, ref limit, ref offset);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (templateStatus.IsSet)
                        parseQueryStringLocalVar["templateStatus"] = ClientUtils.ParameterToString(templateStatus.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSmtpTemplatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSmtpTemplatesApiResponse>();

                        GetSmtpTemplatesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSmtpTemplatesDefaultImplementation(apiResponseLocalVar, templateStatus, limit, offset);

                        Events.ExecuteOnGetSmtpTemplates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSmtpTemplatesDefaultImplementation(e, "/smtp/templates", uriBuilderLocalVar.Path, templateStatus, limit, offset);
                Events.ExecuteOnErrorGetSmtpTemplates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSmtpTemplatesApiResponse"/>
        /// </summary>
        public partial class GetSmtpTemplatesApiResponse : BrevoDotNet.Client.ApiResponse, IGetSmtpTemplatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSmtpTemplatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSmtpTemplatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSmtpTemplatesApiResponse(ILogger<GetSmtpTemplatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetSmtpTemplates? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetSmtpTemplates>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetSmtpTemplates? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTransacBlockedContacts(ref Option<string> startDate, ref Option<string> endDate, ref Option<long> limit, ref Option<long> offset, Option<List<string>> senders);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="senders"></param>
        /// <returns></returns>
        private void ValidateGetTransacBlockedContacts(Option<string> startDate, Option<string> endDate, Option<List<string>> senders)
        {
            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate));

            if (endDate.IsSet && endDate.Value == null)
                throw new ArgumentNullException(nameof(endDate));

            if (senders.IsSet && senders.Value == null)
                throw new ArgumentNullException(nameof(senders));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="senders"></param>
        private void AfterGetTransacBlockedContactsDefaultImplementation(IGetTransacBlockedContactsApiResponse apiResponseLocalVar, Option<string> startDate, Option<string> endDate, Option<long> limit, Option<long> offset, Option<List<string>> senders)
        {
            bool suppressDefaultLog = false;
            AfterGetTransacBlockedContacts(ref suppressDefaultLog, apiResponseLocalVar, startDate, endDate, limit, offset, senders);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="senders"></param>
        partial void AfterGetTransacBlockedContacts(ref bool suppressDefaultLog, IGetTransacBlockedContactsApiResponse apiResponseLocalVar, Option<string> startDate, Option<string> endDate, Option<long> limit, Option<long> offset, Option<List<string>> senders);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="senders"></param>
        private void OnErrorGetTransacBlockedContactsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> startDate, Option<string> endDate, Option<long> limit, Option<long> offset, Option<List<string>> senders)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTransacBlockedContacts(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startDate, endDate, limit, offset, senders);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="senders"></param>
        partial void OnErrorGetTransacBlockedContacts(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> startDate, Option<string> endDate, Option<long> limit, Option<long> offset, Option<List<string>> senders);

        /// <summary>
        /// Get the list of blocked or unsubscribed transactional contacts 
        /// </summary>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="senders">Comma separated list of emails of the senders from which contacts are blocked or unsubscribed (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacBlockedContactsApiResponse"/>&gt;</returns>
        public async Task<IGetTransacBlockedContactsApiResponse?> GetTransacBlockedContactsOrDefaultAsync(Option<string> startDate = default, Option<string> endDate = default, Option<long> limit = default, Option<long> offset = default, Option<List<string>> senders = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTransacBlockedContactsAsync(startDate, endDate, limit, offset, senders, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the list of blocked or unsubscribed transactional contacts 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts (optional)</param>
        /// <param name="limit">Number of documents returned per page (optional, default to 50)</param>
        /// <param name="offset">Index of the first document on the page (optional, default to 0)</param>
        /// <param name="senders">Comma separated list of emails of the senders from which contacts are blocked or unsubscribed (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacBlockedContactsApiResponse"/>&gt;</returns>
        public async Task<IGetTransacBlockedContactsApiResponse> GetTransacBlockedContactsAsync(Option<string> startDate = default, Option<string> endDate = default, Option<long> limit = default, Option<long> offset = default, Option<List<string>> senders = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTransacBlockedContacts(startDate, endDate, senders);

                FormatGetTransacBlockedContacts(ref startDate, ref endDate, ref limit, ref offset, senders);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/blockedContacts"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/blockedContacts");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (senders.IsSet)
                        parseQueryStringLocalVar["senders"] = ClientUtils.ParameterToString(senders.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTransacBlockedContactsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTransacBlockedContactsApiResponse>();

                        GetTransacBlockedContactsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/blockedContacts", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTransacBlockedContactsDefaultImplementation(apiResponseLocalVar, startDate, endDate, limit, offset, senders);

                        Events.ExecuteOnGetTransacBlockedContacts(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTransacBlockedContactsDefaultImplementation(e, "/smtp/blockedContacts", uriBuilderLocalVar.Path, startDate, endDate, limit, offset, senders);
                Events.ExecuteOnErrorGetTransacBlockedContacts(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTransacBlockedContactsApiResponse"/>
        /// </summary>
        public partial class GetTransacBlockedContactsApiResponse : BrevoDotNet.Client.ApiResponse, IGetTransacBlockedContactsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTransacBlockedContactsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTransacBlockedContactsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTransacBlockedContactsApiResponse(ILogger<GetTransacBlockedContactsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetTransacBlockedContacts? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetTransacBlockedContacts>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetTransacBlockedContacts? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTransacEmailContent(ref string uuid);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="uuid"></param>
        /// <returns></returns>
        private void ValidateGetTransacEmailContent(string uuid)
        {
            if (uuid == null)
                throw new ArgumentNullException(nameof(uuid));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uuid"></param>
        private void AfterGetTransacEmailContentDefaultImplementation(IGetTransacEmailContentApiResponse apiResponseLocalVar, string uuid)
        {
            bool suppressDefaultLog = false;
            AfterGetTransacEmailContent(ref suppressDefaultLog, apiResponseLocalVar, uuid);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uuid"></param>
        partial void AfterGetTransacEmailContent(ref bool suppressDefaultLog, IGetTransacEmailContentApiResponse apiResponseLocalVar, string uuid);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uuid"></param>
        private void OnErrorGetTransacEmailContentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string uuid)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTransacEmailContent(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, uuid);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uuid"></param>
        partial void OnErrorGetTransacEmailContent(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string uuid);

        /// <summary>
        /// Get the personalized content of a sent transactional email 
        /// </summary>
        /// <param name="uuid">Unique id of the transactional email that has been sent to a particular contact</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailContentApiResponse"/>&gt;</returns>
        public async Task<IGetTransacEmailContentApiResponse?> GetTransacEmailContentOrDefaultAsync(string uuid, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTransacEmailContentAsync(uuid, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the personalized content of a sent transactional email 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uuid">Unique id of the transactional email that has been sent to a particular contact</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailContentApiResponse"/>&gt;</returns>
        public async Task<IGetTransacEmailContentApiResponse> GetTransacEmailContentAsync(string uuid, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTransacEmailContent(uuid);

                FormatGetTransacEmailContent(ref uuid);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/emails/{uuid}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/emails/{uuid}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Buuid%7D", Uri.EscapeDataString(uuid.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTransacEmailContentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTransacEmailContentApiResponse>();

                        GetTransacEmailContentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/emails/{uuid}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTransacEmailContentDefaultImplementation(apiResponseLocalVar, uuid);

                        Events.ExecuteOnGetTransacEmailContent(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTransacEmailContentDefaultImplementation(e, "/smtp/emails/{uuid}", uriBuilderLocalVar.Path, uuid);
                Events.ExecuteOnErrorGetTransacEmailContent(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTransacEmailContentApiResponse"/>
        /// </summary>
        public partial class GetTransacEmailContentApiResponse : BrevoDotNet.Client.ApiResponse, IGetTransacEmailContentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTransacEmailContentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTransacEmailContentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTransacEmailContentApiResponse(ILogger<GetTransacEmailContentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetTransacEmailContent? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetTransacEmailContent>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetTransacEmailContent? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTransacEmailsList(ref Option<string> email, ref Option<long> templateId, ref Option<string> messageId, ref Option<DateOnly> startDate, ref Option<DateOnly> endDate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="email"></param>
        /// <param name="messageId"></param>
        /// <returns></returns>
        private void ValidateGetTransacEmailsList(Option<string> email, Option<string> messageId)
        {
            if (email.IsSet && email.Value == null)
                throw new ArgumentNullException(nameof(email));

            if (messageId.IsSet && messageId.Value == null)
                throw new ArgumentNullException(nameof(messageId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="email"></param>
        /// <param name="templateId"></param>
        /// <param name="messageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        private void AfterGetTransacEmailsListDefaultImplementation(IGetTransacEmailsListApiResponse apiResponseLocalVar, Option<string> email, Option<long> templateId, Option<string> messageId, Option<DateOnly> startDate, Option<DateOnly> endDate)
        {
            bool suppressDefaultLog = false;
            AfterGetTransacEmailsList(ref suppressDefaultLog, apiResponseLocalVar, email, templateId, messageId, startDate, endDate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="email"></param>
        /// <param name="templateId"></param>
        /// <param name="messageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        partial void AfterGetTransacEmailsList(ref bool suppressDefaultLog, IGetTransacEmailsListApiResponse apiResponseLocalVar, Option<string> email, Option<long> templateId, Option<string> messageId, Option<DateOnly> startDate, Option<DateOnly> endDate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="email"></param>
        /// <param name="templateId"></param>
        /// <param name="messageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        private void OnErrorGetTransacEmailsListDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> email, Option<long> templateId, Option<string> messageId, Option<DateOnly> startDate, Option<DateOnly> endDate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTransacEmailsList(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, email, templateId, messageId, startDate, endDate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="email"></param>
        /// <param name="templateId"></param>
        /// <param name="messageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        partial void OnErrorGetTransacEmailsList(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> email, Option<long> templateId, Option<string> messageId, Option<DateOnly> startDate, Option<DateOnly> endDate);

        /// <summary>
        /// Get the list of transactional emails on the basis of allowed filters This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
        /// </summary>
        /// <param name="email">Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent. (optional)</param>
        /// <param name="templateId">Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email. (optional)</param>
        /// <param name="messageId">Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent. (optional)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailsListApiResponse"/>&gt;</returns>
        public async Task<IGetTransacEmailsListApiResponse?> GetTransacEmailsListOrDefaultAsync(Option<string> email = default, Option<long> templateId = default, Option<string> messageId = default, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTransacEmailsListAsync(email, templateId, messageId, startDate, endDate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the list of transactional emails on the basis of allowed filters This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="email">Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent. (optional)</param>
        /// <param name="templateId">Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email. (optional)</param>
        /// <param name="messageId">Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent. (optional)</param>
        /// <param name="startDate">Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="endDate">Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTransacEmailsListApiResponse"/>&gt;</returns>
        public async Task<IGetTransacEmailsListApiResponse> GetTransacEmailsListAsync(Option<string> email = default, Option<long> templateId = default, Option<string> messageId = default, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTransacEmailsList(email, messageId);

                FormatGetTransacEmailsList(ref email, ref templateId, ref messageId, ref startDate, ref endDate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/emails");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (email.IsSet)
                        parseQueryStringLocalVar["email"] = ClientUtils.ParameterToString(email.Value);

                    if (templateId.IsSet)
                        parseQueryStringLocalVar["templateId"] = ClientUtils.ParameterToString(templateId.Value);

                    if (messageId.IsSet)
                        parseQueryStringLocalVar["messageId"] = ClientUtils.ParameterToString(messageId.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTransacEmailsListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTransacEmailsListApiResponse>();

                        GetTransacEmailsListApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTransacEmailsListDefaultImplementation(apiResponseLocalVar, email, templateId, messageId, startDate, endDate);

                        Events.ExecuteOnGetTransacEmailsList(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTransacEmailsListDefaultImplementation(e, "/smtp/emails", uriBuilderLocalVar.Path, email, templateId, messageId, startDate, endDate);
                Events.ExecuteOnErrorGetTransacEmailsList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTransacEmailsListApiResponse"/>
        /// </summary>
        public partial class GetTransacEmailsListApiResponse : BrevoDotNet.Client.ApiResponse, IGetTransacEmailsListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTransacEmailsListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTransacEmailsListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTransacEmailsListApiResponse(ILogger<GetTransacEmailsListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.GetTransacEmailsList? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.GetTransacEmailsList>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out BrevoDotNet.Model.GetTransacEmailsList? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendTemplate(ref long templateId, SendEmail sendEmail);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmail"></param>
        /// <returns></returns>
        private void ValidateSendTemplate(SendEmail sendEmail)
        {
            if (sendEmail == null)
                throw new ArgumentNullException(nameof(sendEmail));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendEmail"></param>
        private void AfterSendTemplateDefaultImplementation(ISendTemplateApiResponse apiResponseLocalVar, long templateId, SendEmail sendEmail)
        {
            bool suppressDefaultLog = false;
            AfterSendTemplate(ref suppressDefaultLog, apiResponseLocalVar, templateId, sendEmail);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendEmail"></param>
        partial void AfterSendTemplate(ref bool suppressDefaultLog, ISendTemplateApiResponse apiResponseLocalVar, long templateId, SendEmail sendEmail);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendEmail"></param>
        private void OnErrorSendTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, SendEmail sendEmail)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateId, sendEmail);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendEmail"></param>
        partial void OnErrorSendTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, SendEmail sendEmail);

        /// <summary>
        /// Send a template This endpoint is deprecated. Prefer v3/smtp/email instead.
        /// </summary>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTemplateApiResponse"/>&gt;</returns>
        public async Task<ISendTemplateApiResponse?> SendTemplateOrDefaultAsync(long templateId, SendEmail sendEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendTemplateAsync(templateId, sendEmail, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send a template This endpoint is deprecated. Prefer v3/smtp/email instead.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTemplateApiResponse"/>&gt;</returns>
        public async Task<ISendTemplateApiResponse> SendTemplateAsync(long templateId, SendEmail sendEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendTemplate(sendEmail);

                FormatSendTemplate(ref templateId, sendEmail);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates/{templateId}/send"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates/{templateId}/send");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtemplateId%7D", Uri.EscapeDataString(templateId.ToString()));

                    httpRequestMessageLocalVar.Content = (sendEmail as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmail, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendTemplateApiResponse>();

                        SendTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates/{templateId}/send", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendTemplateDefaultImplementation(apiResponseLocalVar, templateId, sendEmail);

                        Events.ExecuteOnSendTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendTemplateDefaultImplementation(e, "/smtp/templates/{templateId}/send", uriBuilderLocalVar.Path, templateId, sendEmail);
                Events.ExecuteOnErrorSendTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendTemplateApiResponse"/>
        /// </summary>
        public partial class SendTemplateApiResponse : BrevoDotNet.Client.ApiResponse, ISendTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendTemplateApiResponse(ILogger<SendTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.SendTemplateEmail? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.SendTemplateEmail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out BrevoDotNet.Model.SendTemplateEmail? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.PostSendFailed? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.PostSendFailed>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.PostSendFailed? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendTestTemplate(ref long templateId, SendTestEmail sendTestEmail);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendTestEmail"></param>
        /// <returns></returns>
        private void ValidateSendTestTemplate(SendTestEmail sendTestEmail)
        {
            if (sendTestEmail == null)
                throw new ArgumentNullException(nameof(sendTestEmail));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendTestEmail"></param>
        private void AfterSendTestTemplateDefaultImplementation(ISendTestTemplateApiResponse apiResponseLocalVar, long templateId, SendTestEmail sendTestEmail)
        {
            bool suppressDefaultLog = false;
            AfterSendTestTemplate(ref suppressDefaultLog, apiResponseLocalVar, templateId, sendTestEmail);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendTestEmail"></param>
        partial void AfterSendTestTemplate(ref bool suppressDefaultLog, ISendTestTemplateApiResponse apiResponseLocalVar, long templateId, SendTestEmail sendTestEmail);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendTestEmail"></param>
        private void OnErrorSendTestTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, SendTestEmail sendTestEmail)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendTestTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateId, sendTestEmail);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="sendTestEmail"></param>
        partial void OnErrorSendTestTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, SendTestEmail sendTestEmail);

        /// <summary>
        /// Send a template to your test list 
        /// </summary>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendTestEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestTemplateApiResponse"/>&gt;</returns>
        public async Task<ISendTestTemplateApiResponse?> SendTestTemplateOrDefaultAsync(long templateId, SendTestEmail sendTestEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendTestTemplateAsync(templateId, sendTestEmail, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send a template to your test list 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">Id of the template</param>
        /// <param name="sendTestEmail"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestTemplateApiResponse"/>&gt;</returns>
        public async Task<ISendTestTemplateApiResponse> SendTestTemplateAsync(long templateId, SendTestEmail sendTestEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendTestTemplate(sendTestEmail);

                FormatSendTestTemplate(ref templateId, sendTestEmail);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates/{templateId}/sendTest"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates/{templateId}/sendTest");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtemplateId%7D", Uri.EscapeDataString(templateId.ToString()));

                    httpRequestMessageLocalVar.Content = (sendTestEmail as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendTestEmail, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendTestTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendTestTemplateApiResponse>();

                        SendTestTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates/{templateId}/sendTest", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendTestTemplateDefaultImplementation(apiResponseLocalVar, templateId, sendTestEmail);

                        Events.ExecuteOnSendTestTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendTestTemplateDefaultImplementation(e, "/smtp/templates/{templateId}/sendTest", uriBuilderLocalVar.Path, templateId, sendTestEmail);
                Events.ExecuteOnErrorSendTestTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendTestTemplateApiResponse"/>
        /// </summary>
        public partial class SendTestTemplateApiResponse : BrevoDotNet.Client.ApiResponse, ISendTestTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendTestTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendTestTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendTestTemplateApiResponse(ILogger<SendTestTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.PostSendFailed? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.PostSendFailed>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.PostSendFailed? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendTransacEmail(SendSmtpEmail sendSmtpEmail);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendSmtpEmail"></param>
        /// <returns></returns>
        private void ValidateSendTransacEmail(SendSmtpEmail sendSmtpEmail)
        {
            if (sendSmtpEmail == null)
                throw new ArgumentNullException(nameof(sendSmtpEmail));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendSmtpEmail"></param>
        private void AfterSendTransacEmailDefaultImplementation(ISendTransacEmailApiResponse apiResponseLocalVar, SendSmtpEmail sendSmtpEmail)
        {
            bool suppressDefaultLog = false;
            AfterSendTransacEmail(ref suppressDefaultLog, apiResponseLocalVar, sendSmtpEmail);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendSmtpEmail"></param>
        partial void AfterSendTransacEmail(ref bool suppressDefaultLog, ISendTransacEmailApiResponse apiResponseLocalVar, SendSmtpEmail sendSmtpEmail);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendSmtpEmail"></param>
        private void OnErrorSendTransacEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SendSmtpEmail sendSmtpEmail)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendTransacEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sendSmtpEmail);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendSmtpEmail"></param>
        partial void OnErrorSendTransacEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SendSmtpEmail sendSmtpEmail);

        /// <summary>
        /// Send a transactional email 
        /// </summary>
        /// <param name="sendSmtpEmail">Values to send a transactional email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTransacEmailApiResponse"/>&gt;</returns>
        public async Task<ISendTransacEmailApiResponse?> SendTransacEmailOrDefaultAsync(SendSmtpEmail sendSmtpEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendTransacEmailAsync(sendSmtpEmail, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send a transactional email 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendSmtpEmail">Values to send a transactional email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTransacEmailApiResponse"/>&gt;</returns>
        public async Task<ISendTransacEmailApiResponse> SendTransacEmailAsync(SendSmtpEmail sendSmtpEmail, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendTransacEmail(sendSmtpEmail);

                FormatSendTransacEmail(sendSmtpEmail);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/email"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/email");

                    httpRequestMessageLocalVar.Content = (sendSmtpEmail as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendSmtpEmail, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendTransacEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendTransacEmailApiResponse>();

                        SendTransacEmailApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/email", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendTransacEmailDefaultImplementation(apiResponseLocalVar, sendSmtpEmail);

                        Events.ExecuteOnSendTransacEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendTransacEmailDefaultImplementation(e, "/smtp/email", uriBuilderLocalVar.Path, sendSmtpEmail);
                Events.ExecuteOnErrorSendTransacEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendTransacEmailApiResponse"/>
        /// </summary>
        public partial class SendTransacEmailApiResponse : BrevoDotNet.Client.ApiResponse, ISendTransacEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendTransacEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendTransacEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendTransacEmailApiResponse(ILogger<SendTransacEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.CreateSmtpEmail? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.CreateSmtpEmail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out BrevoDotNet.Model.CreateSmtpEmail? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSmtpBlockedContactsEmailDelete(ref string email);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="email"></param>
        /// <returns></returns>
        private void ValidateSmtpBlockedContactsEmailDelete(string email)
        {
            if (email == null)
                throw new ArgumentNullException(nameof(email));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="email"></param>
        private void AfterSmtpBlockedContactsEmailDeleteDefaultImplementation(ISmtpBlockedContactsEmailDeleteApiResponse apiResponseLocalVar, string email)
        {
            bool suppressDefaultLog = false;
            AfterSmtpBlockedContactsEmailDelete(ref suppressDefaultLog, apiResponseLocalVar, email);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="email"></param>
        partial void AfterSmtpBlockedContactsEmailDelete(ref bool suppressDefaultLog, ISmtpBlockedContactsEmailDeleteApiResponse apiResponseLocalVar, string email);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="email"></param>
        private void OnErrorSmtpBlockedContactsEmailDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string email)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSmtpBlockedContactsEmailDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, email);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="email"></param>
        partial void OnErrorSmtpBlockedContactsEmailDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string email);

        /// <summary>
        /// Unblock or resubscribe a transactional contact 
        /// </summary>
        /// <param name="email">contact email (urlencoded) to unblock.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpBlockedContactsEmailDeleteApiResponse"/>&gt;</returns>
        public async Task<ISmtpBlockedContactsEmailDeleteApiResponse?> SmtpBlockedContactsEmailDeleteOrDefaultAsync(string email, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SmtpBlockedContactsEmailDeleteAsync(email, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Unblock or resubscribe a transactional contact 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="email">contact email (urlencoded) to unblock.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpBlockedContactsEmailDeleteApiResponse"/>&gt;</returns>
        public async Task<ISmtpBlockedContactsEmailDeleteApiResponse> SmtpBlockedContactsEmailDeleteAsync(string email, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSmtpBlockedContactsEmailDelete(email);

                FormatSmtpBlockedContactsEmailDelete(ref email);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/blockedContacts/{email}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/blockedContacts/{email}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bemail%7D", Uri.EscapeDataString(email.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SmtpBlockedContactsEmailDeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SmtpBlockedContactsEmailDeleteApiResponse>();

                        SmtpBlockedContactsEmailDeleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/blockedContacts/{email}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSmtpBlockedContactsEmailDeleteDefaultImplementation(apiResponseLocalVar, email);

                        Events.ExecuteOnSmtpBlockedContactsEmailDelete(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSmtpBlockedContactsEmailDeleteDefaultImplementation(e, "/smtp/blockedContacts/{email}", uriBuilderLocalVar.Path, email);
                Events.ExecuteOnErrorSmtpBlockedContactsEmailDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SmtpBlockedContactsEmailDeleteApiResponse"/>
        /// </summary>
        public partial class SmtpBlockedContactsEmailDeleteApiResponse : BrevoDotNet.Client.ApiResponse, ISmtpBlockedContactsEmailDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SmtpBlockedContactsEmailDeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SmtpBlockedContactsEmailDeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SmtpBlockedContactsEmailDeleteApiResponse(ILogger<SmtpBlockedContactsEmailDeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSmtpLogMessageIdDelete(ref string messageId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="messageId"></param>
        /// <returns></returns>
        private void ValidateSmtpLogMessageIdDelete(string messageId)
        {
            if (messageId == null)
                throw new ArgumentNullException(nameof(messageId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterSmtpLogMessageIdDeleteDefaultImplementation(ISmtpLogMessageIdDeleteApiResponse apiResponseLocalVar, string messageId)
        {
            bool suppressDefaultLog = false;
            AfterSmtpLogMessageIdDelete(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterSmtpLogMessageIdDelete(ref bool suppressDefaultLog, ISmtpLogMessageIdDeleteApiResponse apiResponseLocalVar, string messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="messageId"></param>
        private void OnErrorSmtpLogMessageIdDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string messageId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSmtpLogMessageIdDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, messageId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="messageId"></param>
        partial void OnErrorSmtpLogMessageIdDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string messageId);

        /// <summary>
        /// Delete an SMTP transactional log 
        /// </summary>
        /// <param name="messageId">MessageId of the transactional log to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpLogMessageIdDeleteApiResponse"/>&gt;</returns>
        public async Task<ISmtpLogMessageIdDeleteApiResponse?> SmtpLogMessageIdDeleteOrDefaultAsync(string messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SmtpLogMessageIdDeleteAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an SMTP transactional log 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">MessageId of the transactional log to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISmtpLogMessageIdDeleteApiResponse"/>&gt;</returns>
        public async Task<ISmtpLogMessageIdDeleteApiResponse> SmtpLogMessageIdDeleteAsync(string messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSmtpLogMessageIdDelete(messageId);

                FormatSmtpLogMessageIdDelete(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/log/{messageId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/log/{messageId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SmtpLogMessageIdDeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SmtpLogMessageIdDeleteApiResponse>();

                        SmtpLogMessageIdDeleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/log/{messageId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSmtpLogMessageIdDeleteDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnSmtpLogMessageIdDelete(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSmtpLogMessageIdDeleteDefaultImplementation(e, "/smtp/log/{messageId}", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorSmtpLogMessageIdDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SmtpLogMessageIdDeleteApiResponse"/>
        /// </summary>
        public partial class SmtpLogMessageIdDeleteApiResponse : BrevoDotNet.Client.ApiResponse, ISmtpLogMessageIdDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SmtpLogMessageIdDeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SmtpLogMessageIdDeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SmtpLogMessageIdDeleteApiResponse(ILogger<SmtpLogMessageIdDeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateSmtpTemplate(ref long templateId, UpdateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="smtpTemplate"></param>
        /// <returns></returns>
        private void ValidateUpdateSmtpTemplate(UpdateSmtpTemplate smtpTemplate)
        {
            if (smtpTemplate == null)
                throw new ArgumentNullException(nameof(smtpTemplate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="smtpTemplate"></param>
        private void AfterUpdateSmtpTemplateDefaultImplementation(IUpdateSmtpTemplateApiResponse apiResponseLocalVar, long templateId, UpdateSmtpTemplate smtpTemplate)
        {
            bool suppressDefaultLog = false;
            AfterUpdateSmtpTemplate(ref suppressDefaultLog, apiResponseLocalVar, templateId, smtpTemplate);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="smtpTemplate"></param>
        partial void AfterUpdateSmtpTemplate(ref bool suppressDefaultLog, IUpdateSmtpTemplateApiResponse apiResponseLocalVar, long templateId, UpdateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="smtpTemplate"></param>
        private void OnErrorUpdateSmtpTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, UpdateSmtpTemplate smtpTemplate)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateSmtpTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, templateId, smtpTemplate);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="templateId"></param>
        /// <param name="smtpTemplate"></param>
        partial void OnErrorUpdateSmtpTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long templateId, UpdateSmtpTemplate smtpTemplate);

        /// <summary>
        /// Update an email template 
        /// </summary>
        /// <param name="templateId">id of the template</param>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IUpdateSmtpTemplateApiResponse?> UpdateSmtpTemplateOrDefaultAsync(long templateId, UpdateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateSmtpTemplateAsync(templateId, smtpTemplate, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update an email template 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">id of the template</param>
        /// <param name="smtpTemplate">values to update in transactional email template</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpTemplateApiResponse"/>&gt;</returns>
        public async Task<IUpdateSmtpTemplateApiResponse> UpdateSmtpTemplateAsync(long templateId, UpdateSmtpTemplate smtpTemplate, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateSmtpTemplate(smtpTemplate);

                FormatUpdateSmtpTemplate(ref templateId, smtpTemplate);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/smtp/templates/{templateId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/smtp/templates/{templateId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtemplateId%7D", Uri.EscapeDataString(templateId.ToString()));

                    httpRequestMessageLocalVar.Content = (smtpTemplate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(smtpTemplate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateSmtpTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateSmtpTemplateApiResponse>();

                        UpdateSmtpTemplateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/smtp/templates/{templateId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateSmtpTemplateDefaultImplementation(apiResponseLocalVar, templateId, smtpTemplate);

                        Events.ExecuteOnUpdateSmtpTemplate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateSmtpTemplateDefaultImplementation(e, "/smtp/templates/{templateId}", uriBuilderLocalVar.Path, templateId, smtpTemplate);
                Events.ExecuteOnErrorUpdateSmtpTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateSmtpTemplateApiResponse"/>
        /// </summary>
        public partial class UpdateSmtpTemplateApiResponse : BrevoDotNet.Client.ApiResponse, IUpdateSmtpTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateSmtpTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateSmtpTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateSmtpTemplateApiResponse(ILogger<UpdateSmtpTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public BrevoDotNet.Model.ErrorModel? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<BrevoDotNet.Model.ErrorModel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out BrevoDotNet.Model.ErrorModel? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
